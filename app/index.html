<!DOCTYPE html>
<html>
  <head>
    <title>Sheets js</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script>
      let client;
      let tokenClient;
      let state;

      function initClient() {
        // https://developers.google.com/discovery/v1/reference/apis/list
        const discoveryRestUrls = {
          sheets: 'https://sheets.googleapis.com/$discovery/rest?version=v4',
        };
        new Promise((callback, onerror) => { 
          gapi.load('client', { callback, onerror });
        })
        .then(() => {
          return gapi.client.init({
            discoveryDocs: [  // preload apis 
              discoveryRestUrls.sheets,
            ]
          });
        })
        .then(() => { 
          client = gapi.client;
          const [token] = [window.localStorage.getItem('token')].map(JSON.parse);
          if (token?.access_token) {
            gapi.client.setToken(token);
          }
          console.log('client initialized');
          updateUi({ initialized: !!tokenClient });
         });
      }
      function initTokenClient() {
        scopes = [
          'https://www.googleapis.com/auth/spreadsheets.readonly',
        ];
        // https://developers.google.com/identity/oauth2/web/guides/use-token-model
        // https://console.cloud.google.com/apis/credentials/oauthclient/588879659786-96ialt5l1bn240naa55eh7gberlo66ds.apps.googleusercontent.com
        tokenClient = google.accounts.oauth2.initTokenClient({  // implicit grant flow
          client_id: '588879659786-96ialt5l1bn240naa55eh7gberlo66ds.apps.googleusercontent.com',
          scope: scopes.join(' '),
          prompt: '',  // instead of `consent`
          callback: ''
        });
        console.log('token client initialized');
        updateUi({ initialized: !!client });
      }
      function signIn() {
        return new Promise((resolve, reject) => {
          tokenClient.callback = ({ error }) => {
            if (error) { reject(error) }
            else { resolve() }  // gapi.client.getToken() is updated automatically
          };
          tokenClient.requestAccessToken();
        })
        .then(() => { 
          window.localStorage.setItem('token', JSON.stringify(gapi.client.getToken()));
          console.log('authenticated');
          updateUi({ authenticated: true });
        });
      }
      function signOut() {
        const credentials = gapi.client.getToken();
        if (credentials) {
          google.accounts.oauth2.revoke(credentials.access_token, () => { 
            gapi.client.setToken('');
            window.localStorage.removeItem('token');
            console.log('token revoked');
            updateUi({ tokenRevoked: true });
          });
        }
      }
      function loadSpreadsheetValues() {
        updateUi({ loadingValues: true });
        // https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/get
        gapi.client.sheets.spreadsheets.values.get({ 
          spreadsheetId: '1UbJN1IUOu28ujbab_zkdYrPaoIS3uByk3twBACqTxh4',
          range: 'BAL',  
        })
        .then(({ result, status }) => { 
          if (status == 200) {
            console.log('values loaded');
            updateUi({ values: result.values, accountsByCategory: loadAccountsCategories() });
          }
        })
        .catch((error) => {
          if (error?.status === 401 || error?.status === 403) {
            gapi.client.setToken('');
            window.localStorage.removeItem('token');
            console.log('unauthorized');
            updateUi({ unauthorized: true, loadingValuesError: error });
          }
        });
      }
      function loadAccountsCategories() {
        // TODO: load from spreadhseet
        return new Map([
          ['expenses', new Set(['allowance', 'borica', 'carpool', 'electro', 'entertainment', 'eyecare', 
                    'fee', 'fitness', 'food', 'games', 'groom', 'gviva', 'gvsm', 
                    'home', 'leisure', 'metro', 'office', 'pztax', 'sbst', 'sftax', 
                    'shoa', 'ski', 'socj', 'sport', 'svod', 'telk', 'toplo', 
                    'unknown', 'vgsm', 'vviva'])],

          ['medical', new Set(['eyecare', 'gvsm', 'vgsm'])],
          
          ['income', new Set(['c1080', 'c9277', 'pens', 'socp'])],
          
          ['utilities', new Set(['electro', 'gviva', 'pztax', 'sbst', 'sftax', 'shoa', 'socj', 
                        'svod', 'toplo', 'vviva'])],
        ]);
      }
      function handleTBodyClick(event) {
        if (event.target instanceof HTMLTableCellElement) {
          const { col } = event.target.dataset;
          const { month, account } = event.target.parentElement.dataset;
          updateUi({ toggle: { col, month, account }});
        }
      }
      function updateUi(event = {}) {
        if (event.initialized) {
          updateUiLoadingClient({ visible: false });
          updateUiVisibility();
          if (gapi.client.getToken()?.access_token) {
            loadSpreadsheetValues();
          }
        }
        if (event.authenticated) {
          updateUiVisibility();
          loadSpreadsheetValues();
        }
        if (event.tokenRevoked) {
          updateUiVisibility();
          updateUiValuesTable({});   // clear table
        }
        if (event.unauthorized) {
          updateUiVisibility();
          updateUiValuesTable({});   // clear table
        }
        if (event.loadingValues) {
          updateUiLoadingValues({ visible: true });
        }
        if (event.loadingValuesError) {
          updateUiLoadingValues({ visible: false });
        }
        if (event.values) {
          updateUiLoadingValues({ visible: false });
          const { values, accountsByCategory } = event;
          const index = new Map(values[0].map((x,i) => [x,i]));
          const header = values.shift().filter(x => ['DT','AMNT','ACCT'].includes(x));
          state = { index, values, accountsByCategory, filter: new Set() };
          updateUiValuesTable({ index, header, values, accountsByCategory });
          updateUiSummary({ index, values, accountsByCategory });
        }
        if (event.toggle) {
          const { col, month, account } = event.toggle;
          if (['DT','ACCT'].includes(col)) {
            const { filter } = state;
            if (filter.has(col)) {
              filter.delete(col);
            } else {
              filter.add(col);
            }
            updateUiFilterValuesTable(filter, { month, account });

            const { index, values, accountsByCategory } = state;
            updateUiSummary({ index, values, accountsByCategory, filter, month, account });
          }
        }
      }
      function updateUiValuesTable({ index, header, values, accountsByCategory }) {
        [document.querySelector('.div-values table')].filter(Boolean).forEach(table => {
          [document.createElement('thead')].forEach(thead => {
            table.tHead?.remove();
            if (header) {
              [document.createElement('tr')].forEach(tr => {
                header.map(col => [document.createTextNode(col), document.createElement('th')])
                  .forEach(([text, th]) => {
                    th.appendChild(text);
                    tr.appendChild(th);
                  });
                thead.appendChild(tr);
              });
            }
            table.appendChild(thead);
          });

          [document.createElement('tbody')].forEach(tbody => {
            const [tBody] = Array.from(table.tBodies);
            tBody?.remove();
            if (values) {
              const highlight = makeAlternateHighlight();
              const mergeSameDay = makeMergeSameDay();

              values.map(row => [row, document.createElement('tr')])
                .forEach(([row, tr]) => {
                  header.map(col => [col, row[index.get(col)]])
                    .map(([col, value]) => [col, document.createTextNode(value), document.createElement('td')])
                    .forEach(([col, text, td]) => {
                        td.dataset.col = col;
                        td.appendChild(text);
                        tr.appendChild(td);
                    });
  
                  const account = row[index.get('ACCT')];
                  tr.dataset.account = account;
                  tr.dataset.month = new Intl.DateTimeFormat('en', { year: 'numeric', month: 'numeric' }).format(new Date(row[index.get('DT')]));
                  tr.dataset.date = row[index.get('DT')];

                  const categories = Array.from(accountsByCategory.entries())
                    .flatMap(([category, categoryAccounts]) => categoryAccounts.has(account) ? [category] : []);
                  tr.classList.add(...categories);

                  highlight(tr);
                  mergeSameDay(tr);
                  tbody.appendChild(tr);
                });
              tbody.addEventListener('click', handleTBodyClick);
            }
            table.appendChild(tbody);
          });
        });
      }
      function updateUiFilterValuesTable(filter, { month, account }) {
        [document.querySelector('.div-values table')].filter(Boolean).forEach(table => {
          const [tbody] = Array.from(table.tBodies);
          const highlight = makeAlternateHighlight();
          const mergeSameDay = makeMergeSameDay();
          
          const attributes = [
            filter.has('DT') && `[data-month='${month}']`,
            filter.has('ACCT') && `[data-account='${account}']`,
          ].filter(Boolean).join('');

          if (attributes) {
            tbody.querySelectorAll(`tr:not(:where(tr${attributes}))`).forEach(tr => { 
              tr.classList.toggle('d-none', true);
            });
            tbody.querySelectorAll(`tr${attributes}`).forEach(tr => { 
              tr.classList.toggle('d-none', false);
              highlight(tr);
              mergeSameDay(tr);
            });
          } else {
            tbody.querySelectorAll('tr').forEach(tr => { 
              tr.classList.toggle('d-none', false);
              highlight(tr);
              mergeSameDay(tr);
            });
          }
        });
      }
      function updateUiVisibility() {
        updateUiLogin({ visible: !client.getToken(), disabled: !!client.getToken() });
        updateUiLogout({ visible: !!client.getToken(), disabled: !client.getToken() });
        updateUiSummary({ visible: !!client.getToken() });
        updateUiValues({ visible: !!client.getToken() });
      }
      function updateUiLogin({ visible, disabled }) {
        [document.querySelector('.btn-login')].filter(Boolean).forEach(el => {
          el.disabled = disabled;
          el.classList.toggle('d-none', !visible);
        });
      }
      function updateUiLogout({ visible, disabled }) {
        [document.querySelector('.btn-logout')].filter(Boolean).forEach(el => {
          el.disabled = disabled;
          el.classList.toggle('d-none', !visible);
        });
      }
      function updateUiSummary({ visible, index, values, accountsByCategory, filter, month, account }) {
        [document.querySelector('.div-summary')].filter(Boolean).forEach(div => {
          if (visible !== undefined) {
            div.classList.toggle('d-none', !visible);
          }
          if (index && values && accountsByCategory) {
            [div.querySelector('p')].forEach(el => {

              if (filter) {
                // only filter acct, but dont filter by month to make stat past years
                if (filter.has('ACCT')) {
                  values = values.filter(row => account === row[index.get('ACCT')]);
                }
              }

              const categoriesByAccountOf = ({ accountsByCategory }) => {
                const collectCategoriesByAccountOf = category => (categoriesByAccount, account) => {
                  const categories = categoriesByAccount.get(account) ?? categoriesByAccount.set(account, []).get(account);
                  categories.push(category);
                  return categoriesByAccount;
                };
                const collectCategoriesByAccount = (categoriesByAccount, [category, accounts]) => {
                  return Array.from(accounts)
                    .reduce(collectCategoriesByAccountOf(category), categoriesByAccount);
                };
                return Array.from(accountsByCategory.entries())
                  .reduce(collectCategoriesByAccount, new Map);
              };
                
              const monthOf = dt => new Intl.DateTimeFormat('en', { year: 'numeric', month: 'numeric' }).format(dt);
              const yearOf = dt => new Intl.DateTimeFormat('en', { year: 'numeric' }).format(dt);

              const field = function (col, fn) { const k = state.index.get(col); return fn ? value => fn(value[k]) : value => value[k] };
              const fieldDt = field('DT', x => new Date(x));
              const fieldAcct = field('ACCT');
              const fieldAmnt = field('AMNT');

              const parseMonth = month => (
                [new RegExp(/^(\d+)\/(\d+)$/).exec(month)]
                .filter(Boolean)
                .flatMap(([_, m, y]) => { const dt = new Date(y, m - 1); return dt.getFullYear() ? [dt] : [] })
              );
              
              const selectPeriod = ({ filter, month }) => {
                const maybePeriodOf = (keyOf, targetKeys) => dt => {
                  const key = keyOf(dt);
                  return targetKeys.has(key) ? [key] : [];
                };

                if (month && filter && filter.has('DT')) {
                  const [dt] = parseMonth(month);
                  if (dt) {
                    const monthOfDt = monthOf(dt); // month
                    const lastYearMonthOfDt = monthOf(new Date(dt.getFullYear() - 1, dt.getMonth()));
                    const targetMonths = new Set([monthOfDt, lastYearMonthOfDt]);
                    return maybePeriodOf(monthOf, targetMonths);
                  }
                }

                const dt = new Date();  // today
                const yearOfDt = yearOf(new Date(dt.getFullYear(), 0));
                const lastYearOfDt = yearOf(new Date(dt.getFullYear() - 1, 0));
                const targetYears = new Set([yearOfDt, lastYearOfDt]);
                return maybePeriodOf(yearOf, targetYears);
              };

              // values :: ...(dt amnt acct)
              // expenses :: { values, maybePeriodOf } -> ...[period acct amnt]
              const expensesOf = ({ values, maybePeriodOf }) => {
                const maybeExpenseOf = value => {
                  const [period] = maybePeriodOf(fieldDt(value));
                  return period === undefined ? [] : [[period, fieldAcct(value), parseFloat(fieldAmnt(value))]];
                };
                return values.flatMap(maybeExpenseOf);
              };

              // expensesByCategoryOf :: { expenses, categoriesByAccount } -> { category -> expenses }
              const expensesByCategoryOf = ({ expenses, categoriesByAccount }) => {
                const maybeExpenseWithCategory = expense => {
                  const categories = categoriesByAccount.get(expense[1]);
                  return categories === undefined ? [] : categories.map(category => [category, expense]);
                };
                const collectExpensesByCategory = (expensesByCategory, [category, expense]) => {
                  const expenses = (expensesByCategory.get(category) ?? expensesByCategory.set(category, []).get(category));
                  expenses.push(expense);
                  return expensesByCategory;
                };
                return expenses.flatMap(maybeExpenseWithCategory)
                  .reduce(collectExpensesByCategory, new Map);
              };

              // totalByPeriodByCategory :: { expensesByCategory } -> { category -> { period -> total } }
              const totalByPeriodByCategoryOf = ({ expensesByCategory }) => {
                const collectExpensesByPeriod = (expensesByPeriod, expense) => {
                  const expenses = expensesByPeriod.get(expense[0]) ?? expensesByPeriod.set(expense[0], []).get(expense[0]);
                  expenses.push(expense);
                  return expensesByPeriod;
                };
                const collectTotal = (total, expense) => total + expense[2];
                const collectTotalByPeriod = (totalByPeriod, [period, expenses]) => {
                  const total = expenses.reduce(collectTotal, 0);
                  return totalByPeriod.set(period, total);
                };
                const collectTotalByPeriodByCategory = (totalByPeriodByCategory, [category, expenses]) => {
                  const expensesByPeriod = expenses.reduce(collectExpensesByPeriod, new Map);
                  const totalByPeriod = Array.from(expensesByPeriod)
                    .reduce(collectTotalByPeriod, new Map);
                  return totalByPeriodByCategory.set(category, totalByPeriod);
                };
                return Array.from(expensesByCategory.entries())
                  .reduce(collectTotalByPeriodByCategory, new Map);
              };

              // summaryOf :: { totalByPeriodByCategory } -> "$total in $period,... for $category \n..."
              const summaryOf = ({ totalByPeriodByCategory }) => {
                const collectPeriodsSummaries = (periodsSummaries, [period, total]) => {
                  periodsSummaries.push(`${total.toFixed(0)} in ${period}`);
                  return periodsSummaries;
                };
                const collectCategorySummaries = (categorySummaries, [category, totalByPeriod]) => {
                  const periodsSummaries = Array.from(totalByPeriod.entries())
                    .reduce(collectPeriodsSummaries, [])
                    .join(', and ');
                  categorySummaries.push(`${periodsSummaries} for ${category}`);
                  return categorySummaries;
                };
                return Array.from(totalByPeriodByCategory)
                  .reduce(collectCategorySummaries, [])
                  .join('\n');
              };

              const maybePeriodOf = selectPeriod({ filter, month });
              const expenses = expensesOf({ values, maybePeriodOf });
              const categoriesByAccount = categoriesByAccountOf({ accountsByCategory });
              const expensesByCategory = expensesByCategoryOf({ expenses, categoriesByAccount });
              const totalByPeriodByCategory = totalByPeriodByCategoryOf({ expensesByCategory });
              el.innerText = summaryOf({ totalByPeriodByCategory });
            });
          }
        });
      }
      function updateUiValues({ visible }) {
        [document.querySelector('.div-values')].filter(Boolean).forEach(el => {
          el.classList.toggle('d-none', !visible);
        });
      }
      function updateUiLoadingValues({ visible }) {
        [document.querySelector('.label-loading-values')].forEach(el => {
          el.classList.toggle('d-none', !visible);
        });
      }
      function updateUiLoadingClient({ visible }) {
        [document.querySelector('.label-loading-client')].forEach(el => {
          el.classList.toggle('d-none', !visible);
        });
      }
      function makeAlternateHighlight() {
        let lastDt;
        let highlight = true;
        return function (tr) {
          if (lastDt !== tr.dataset.date) {
            highlight = !highlight;
            lastDt = tr.dataset.date;
          }
          tr.classList.toggle('highlighted', highlight);
        }
      }
      function makeMergeSameDay() {
        let lastDt;
        let lastTd;
        return function (tr) {
          const td = Array.from(tr.cells).find(td => td.dataset.col === 'DT');
          if (lastDt !== tr.dataset.date) {
            lastDt = tr.dataset.date;
            lastTd = td;
          }
          const isLastTd = (td === lastTd);
          td.classList.toggle('d-none', !isLastTd);
          td.rowSpan = 1;
          lastTd.rowSpan += (isLastTd ? 0 : 1);
        }
      }
    </script>
    <script src="https://apis.google.com/js/api.js" onload="initClient()" async defer></script>
    <script src="https://accounts.google.com/gsi/client" onload="initTokenClient()" async defer></script>    
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        display: flex;
        flex-direction: column;
        height: 100%;
        margin: 0px;
        padding: 8px;
        position: absolute;
        row-gap: 8px;
        width: 100%;
      }
      .div-values {
        flex: 1 1 auto;
        overflow: auto;
      }
      .div-values table {
        border-spacing: 0px;
        width: 100%;
      }
      .div-values table thead tr {
        background-color: gray;
        color: white;
        position: sticky;
        top: 0px;
      }
      .div-values table tbody tr td[data-col='AMNT'] {
        color: darkgray;
      }
      .div-values table tbody tr.expenses td[data-col='AMNT'] {
        color: inherit;
      }
      .div-values table tbody tr.utilities td[data-col='AMNT'] {
        font-weight: bolder;
        color: orangered;
      }
      .div-values table tbody tr.income td[data-col='AMNT'] {
        font-weight: bolder;
        color: forestgreen;
      }
      .d-none {
        display: none;
      }
      .highlighted {
        background-color: lightgray;
      }
    </style>
  </head>
  <body>
    <p class="label-loading-client">Loading...</p>
    <div>
      <button class="btn-login d-none" onclick="signIn()" disabled>Sign In</button>
      <button class="btn-logout d-none" onclick="signOut()" disabled>Sign Out</button>
    </div>
    <p class="label-loading-values d-none">Loading values...</p>
    <div class="div-summary d-none">
      <p></p>
    </div> 
    <div class="div-values d-none">
      <table></table>
    </div>
  </body>
</html>